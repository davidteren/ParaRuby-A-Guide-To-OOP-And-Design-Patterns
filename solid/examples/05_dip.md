# DIP

## EXAMPLE 1

> **BAD**

```ruby
class ReportGenerator
  # Violates the DIP because it depends on the concrete implementation
  # of the PDFFormatter class, rather than on an abstraction
  def generate(data)
    formatter = PDFFormatter.new
    formatter.format(data)
  end
end

class PDFFormatter
  def format(data)
    # code to generate a PDF report
  end
end
```

This code violates the DIP because the ReportGenerator class depends on the concrete implementation of the PDFFormatter class, rather than on an abstraction. In particular, the generate method creates a new instance of the PDFFormatter class and calls the format method on it, without knowing or caring what class the object belongs to. This means that if we want to change the way the reports are generated, for example by using a different class, such as CSVFormatter, we have to modify the generate method to create a new instance of the CSVFormatter class instead of the PDFFormatter class.

> **Good**

Here is an example of good Ruby code that follows the Dependency Inversion Principle (DIP), which is one of the principles of the SOLID design principles:

```ruby
# High-level class that defines the public API for generating reports
class ReportGenerator
  # Follows the DIP because it depends on an abstraction, Formatter,
  # rather than on a concrete implementation, such as PDFFormatter
  def generate(data, formatter)
    formatter.format(data)
  end
end

# Abstract base class that defines the interface for formatting data
class Formatter
  def format(data)
    raise NotImplementedError
  end
end

# Concrete class that provides the implementation for generating PDF reports
class PDFFormatter < Formatter
  def format(data)
    # code to generate a PDF report
  end
end

# Concrete class that provides the implementation for generating CSV reports
class CSVFormatter < Formatter
  def format(data)
    # code to generate a CSV report
  end
end

# Concrete class that provides the implementation for generating XLSX reports
class XLSXFormatter < Formatter
  def format(data)
    # code to generate an XLSX report
  end
end

```

This code follows the DIP because the ReportGenerator class depends on the abstraction provided by the Formatter class, rather than on the concrete implementations of the PDFFormatter, CSVFormatter, and XLSXFormatter classes. In particular, the generate method accepts a formatter object as an argument and calls the format method on it, without knowing or caring what class the object belongs to. This means that we can change the way the reports are generated by creating a new class that derives from the Formatter class and implementing the format method, and then passing an instance of the new class to the generate method. The generate method will be able to use the format method without needing to be modified.

***

| [Previous](04\_isp.md) | [Index](../../) |   |
| ---------------------- | --------------- | - |
